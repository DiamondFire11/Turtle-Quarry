---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Will.
--- DateTime: 11/26/2020 6:41 PM
---
os.loadAPI("serverScripts/taskManager.lua")
os.loadAPI("serverScripts/timeoutRead.lua")
os.loadAPI("serverScripts/timeoutListen.lua")
os.loadAPI("serverScripts/stringSplit.lua")
os.loadAPI("serverScripts/turtleManager.lua")
os.loadAPI("serverScripts/numericalRound.lua")

-- Global peripherals
local monitor = peripheral.wrap("left")
local modem = peripheral.wrap("right")

-- RedNet ports
local CLIENT = 451
local SERVER = 450
local TURTLE = 453

-- Main server loop
function main()
    term.clear()
    term.setCursorPos(1,1)
    local jobList = {} -- Initialize the task list array, (hard limited to 4 on client)
    while true do
        -- "Multi Threading" implementation of the task server and command server
        parallel.waitForAll(function() jobList = taskServer(jobList) end, function() jobList = commandServer(jobList) end)
    end
end

-- Main task server, will output the task information to the monitor, will use terminal as log, and will maintain
-- active tasks and tracking of deployed turtles via heartbeat.  Will clean up tasks marked for deletion
function taskServer(jobList)
    if #jobList == 0 then
        resetMonitor()
        monitor.setCursorPos(18, 10)
        monitor.write("No active tasks!!")
    else
        resetMonitor()
        for taskID,taskData in pairs(jobList) do
            displayTaskData(jobList, taskID)

            -- Initialize new tasks
            if jobList[taskID]:getStatus() == "INITIALIZE" then
                -- Get the S Value for this task and assign it to the task object
                local s = calculateQuarrySize(jobList, taskID)
                jobList[taskID]:setSValue(s)

                sleep(0.1)
                local initialPositions = calculateInitialPositions(jobList, taskID)
                print("Task", taskID, ": s =", jobList[taskID]:getSValue())

                -- Deploy task turtles
                while jobList[taskID]:getTurtleCount() < jobList[taskID]:getSegmentationSize() do
                    print("Task", taskID, "- Attempting to deploy turtle", jobList[taskID]:getTurtleCount()+1)
                    if turtleManager.deploy() then
                        jobList[taskID]:addTurtle()
                        displayTaskData(jobList, taskID)

                        local initialPosition = initialPositions[jobList[taskID]:getTurtleCount()]
                        sendTaskInfo(jobList, taskID, initialPosition) -- Send turtle task data
                    end
                end

                -- Update task status to running
                jobList[taskID]:setStatus("RUNNING")
            end

            -- Check for completed tasks
            if jobList[taskID]:getStatus() == "RUNNING" then
                --if jobList[taskID]:getTurtleCount() == 0 then
                --    jobList[taskID]:setStatus("DEAD")
                --end
            end

            -- Remove a dead task from the task list
            if jobList[taskID]:getStatus() == "DEAD" then
                table.remove(jobList, taskID)
            end
        end
    end
    return jobList
end

function sendTaskInfo(jobList, taskID, initialPosition)
    local x = initialPosition.x
    local y = initialPosition.y
    local z = initialPosition.z

    local depth = jobList[taskID]:getDepth()
    local length
    local width

    local type = jobList[taskID]:getQuarryType()
    if type == "A" or type == "B" then
        width = jobList[taskID]:getSValue()
        length = jobList[taskID]:getSValue()
    end

    if type == "C1" then
        width = jobList[taskID]:getWidth()
        length = jobList[taskID]:getSValue()
    end

    if type == "C2" then
        width = jobList[taskID]:getSValue()
        length = jobList[taskID]:getLength()
    end

    local data = table.pack(taskID,x,y,z,length,width,depth)

    -- Wait for turtle to signal it is ready to receive task data
    print("Waiting for turtle to boot.")

    local isNotReady = true
    while isNotReady do
        modem.open(SERVER)
        local event, modemSide, senderChannel, replyChannel, message, senderDistance = os.pullEvent("modem_message")
        modem.close(SERVER)

        if message == "READY" then
            isNotReady = false
        end
    end

    print("Sending task data to turtle")
    sleep(2)
    modem.transmit(TURTLE,SERVER,data)
end

function calculateInitialPositions(jobList, taskID)
    local initPos = {}
    local type = jobList[taskID]:getQuarryType()

    if type == "A" or type == "B" then
        for i = 1, math.sqrt(jobList[taskID]:getSegmentationSize()) do
            local z = jobList[taskID]:getZ() + jobList[taskID]:getSValue()*(i-1)
            for j = 1, math.sqrt(jobList[taskID]:getSegmentationSize()) do
                local x = jobList[taskID]:getX() + jobList[taskID]:getSValue()*(j-1)
                table.insert(initPos, vector.new(x,jobList[taskID]:getY(),z))
            end
        end
        return initPos

    end

    if type == "C1" then
        for i = 1, jobList[taskID]:getSegmentationSize() do
            local z = jobList[taskID]:getZ() + jobList[taskID]:getSValue()*(i-1)
            table.insert(initPos, vector.new(jobList[taskID]:getX(),jobList[taskID]:getY(),z))
        end
        return initPos
    end
    if type == "C2" then
        for i = 1, jobList[taskID]:getSegmentationSize() do
            local x = jobList[taskID]:getX() + jobList[taskID]:getSValue()*(i-1)
            table.insert(initPos, vector.new(x,jobList[taskID]:getY(),jobList[taskID]:getZ()))
        end
        return initPos
    end
end

-- This will calculate the S value which is the segmentation value for the length and width of the total quarry area
-- The S value becomes the length and width of each sub quarry.  This value will also be used to position the turtles
function calculateQuarrySize(jobList, taskID)
    local segSize = jobList[taskID]:getSegmentationSize()
    local length = jobList[taskID]:getLength()
    local width = jobList[taskID]:getWidth()
    local squareRoot = math.sqrt(segSize)

    -- Check if quarry is square and the segSize is even if so use the ideal case "A"
    -- If the quarry is not idea (rectangular or odd segSize use case B, C1, or C2)
    if (squareRoot - math.floor(squareRoot)) == 0 and length == width then
        jobList[taskID]:setQuarryType("A")
        return math.ceil(math.sqrt((length*width)/segSize)) -- <-- This is the S value for case A
    end
    if math.abs(squareRoot - math.floor(squareRoot)) > 0 and length == width then
        segSize = math.pow(numericalRound.round(squareRoot, 0), 2)
        jobList[taskID]:setSegmentationSize(segSize)
        jobList[taskID]:setQuarryType("B")
        return math.ceil(math.sqrt((length*width)/segSize)) -- <-- This is the S value for case B
    end
    if length > width then
        jobList[taskID]:setQuarryType("C1")
        return math.ceil(length/segSize) -- <-- This is the S value for case C1
    else
        jobList[taskID]:setQuarryType("C2")
        return math.ceil(width/segSize) -- <-- This is the S value for case C2
    end
end

-- Simple command interpreter that allows a remote user to
function commandServer(jobList)
    local command = timeoutListen.timedListen(1, SERVER, modem)
    deleteTask(jobList)
    interpretCommand(command, jobList)
    return jobList
end

-- Interpret the incoming command and call the appropriate function, if command does not exist inform the client
function interpretCommand(command,jobList)
    local splitCommand = stringSplit.split(command, " ")
    if splitCommand[1] ~= nil then
        if splitCommand[1]:upper() == "NEW" then
            -- Sanitize input command function
            local sanitizedCommand = sanitizeInput(splitCommand)
            newTask(jobList,sanitizedCommand[2],sanitizedCommand[3],sanitizedCommand[4],sanitizedCommand[5],splitCommand[6],splitCommand[7],splitCommand[8])
            modem.transmit(CLIENT,SERVER,"Command Successful")
        elseif splitCommand[1]:upper() == "DELETE" then
            print("Deleting task ", splitCommand[2])
            deleteTask(jobList,splitCommand[2])
            modem.transmit(CLIENT,SERVER,"Command Successful")
        elseif command:upper() == "UPDATE" then
            -- Send response with number of active tasks
            modem.transmit(CLIENT,SERVER,#jobList)
        else
            -- Send command unknown response to client over Rednet
            modem.transmit(CLIENT,SERVER,"Unknown Command")
        end
    end
    return jobList
end

function sanitizeInput(splitCommand)
    local temp = {}
    table.insert(temp,splitCommand[1])
    if tonumber(splitCommand[2]) == nil then
        table.insert(temp, 10)
    else
        table.insert(temp, splitCommand[2])
    end

    if tonumber(splitCommand[3]) == nil then
        table.insert(temp, 10)
    else
        table.insert(temp, splitCommand[3])
    end

    if tonumber(splitCommand[4]) == nil then
        table.insert(temp, 10)
    else
        table.insert(temp, splitCommand[4])
    end

    if tonumber(splitCommand[5]) == nil then
        table.insert(temp, 4)
    else
        table.insert(temp, splitCommand[5])
    end
    return temp
end

-- Creates new task and adds it to the task manager
function newTask(jobList, length, width, depth, segmentationSize, x, y, z)
    if #jobList < 4 then
        table.insert(jobList, taskManager.taskDaemon:newEvent("QUARRY", length, width, depth, segmentationSize, x, y, z))
        -- Send success signal over Rednet to command client
    else
        -- Send fail signal over Rednet to command client
    end
    return jobList
end

-- Marks a task for deletion, on next heartbeat all turtles assigned to that task will be recalled
function deleteTask(jobList, ID)
    local taskID = tonumber(ID)
    if jobList[taskID] ~= nil then
        jobList[taskID]:setStatus("CANCELLED")
        -- Send success signal over Rednet to command client
    else
        -- Send fail signal over Rednet to command client
    end
    return jobList
end

-- Output data to monitor
function displayTaskData(jobList, taskID)
    local verticalShift
    local horizontalShift

    -- Task data position offsetting so that all the tasks don't write on top of each other
    if taskID % 2 == 0 then
        verticalShift = 10
        if taskID > 2 then
            horizontalShift = 26
        else
            horizontalShift = 1
        end
    else
        verticalShift = 1
        if taskID > 2 then
            horizontalShift = 26
        else
            horizontalShift = 1
        end
    end

    -- Task Data output (!!this is not final, will change at release!!)
    monitor.setCursorPos(horizontalShift, verticalShift + 2)
    monitor.write("Task "..taskID.." - "..jobList[taskID]:getStatus())
    monitor.setCursorPos(horizontalShift, verticalShift + 3)
    monitor.write("Location: "..jobList[taskID]:getX()..", "..jobList[taskID]:getY()..", "..jobList[taskID]:getZ())
    monitor.setCursorPos(horizontalShift, verticalShift + 4)
    monitor.write("Volume: "..(jobList[taskID]:getLength()*jobList[taskID]:getWidth()*jobList[taskID]:getDepth()).." blocks")
    monitor.setCursorPos(horizontalShift, verticalShift + 5)
    monitor.write("Turtles Deployed: "..jobList[taskID]:getTurtleCount())
end

function resetMonitor()
    monitor.clear()
    monitor.setCursorPos(10,1)
    monitor.write("DiamondFire11's Quarry C&C Server")
end

main()